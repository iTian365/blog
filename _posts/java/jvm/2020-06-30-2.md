---
layout: post
title: 深入理解JVM（二）【JVM运行时内存区域】
category: jvm
tags: [JVM]
no-post-nav: true
excerpt: Java运行时会将内存交给虚拟机进行把控，可以减少内存泄漏和内存溢出的概率，所以需要了解JVM运行时的内存区域，明白每个区域的用途，以及创建和销毁时间，保证程序稳定的运行
---

## 1. JVM运行时数据区域详解

![JVM运行时数据区域图解](/assets/images/posts/java/jvm/2020-06-30-2/jvm_run_data_area.png)

* 线程共享区域：只会有一份，所有线程共享，可能会存在并发的问题，使用时需谨慎
* 线程隔离的区域: 每个线程独占的空间


> 程序计数器:

* 一块比较小的内存区域，是线程私有的，生命周期与线程相同
* 可以看作是当前线程执行到的字节码的行号指示器
* 多线程进行切换执行时，在切换回来的时候可以恢复到当前之前执行的位置，继续执行下面的指令
* 如果执行的是Java方法，记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，计数器值为空（Undefined）
* 此内存区域是唯一一个在Java虚拟机规范中没有规定任何 OutOfMemoryError情况的区域

> Java虚拟机栈

* 线程私有，生命周期与线程相同
* 每个方法在执行的同时都会创建一个栈帧，存储局部变量表、操作数栈、动态链接、方法出口等信息
    + 局部变量表存放内容：
        + 编译器可知的基本数据类型（boolean、byte、char、shor、int、float、long、double）
        + 对象引用(reference类型)可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置
        + returnAddress类型：指向了一条字节码指令的地址
    + 局部变量表所需的内存空间在编译期间已经完成分配，所以一个方法在帧中分配的空间完全确定，运行期间的局部变量表的大小不会改变
    
* 异常情况：
    + StackOverflowError：线程请求的栈深度大于虚拟机允许的深度
    + OutOfMemoryError：进行扩展时已经无法申请到足够的内存
      


## 2. HostSpot虚拟机具体实现



